module FileSystem

(* use list.Append as A *)
(* use list.List as L *)
(* use list.Length as Le *)
(* use list.Distinct as Ld *)
(* use list.Mem as Lm *)
use set.Fset
use map.Map
use int.Int
use seq.Seq, seq.Mem, seq.Distinct

(* Arbitrary type for a node of our tree *)
type elt

(* Verifies if two nodes are equal *)
val equal (e1 e2 : elt) : bool
  ensures { result <-> e1 = e2 }

val list_mem (x : elt) (l: seq elt) : bool
  ensures { mem x l }

(* Indicates if two nodes make an edge in our tree *)
predicate edge (x y : elt) (f : elt -> elt) =
    f x = y

predicate path (f: elt -> elt) (x y: elt) (p: seq elt)
= let n = length p in
  n = 0 /\ x = y
\/
  n > 0 /\
  p[0] = x /\
  (forall i. 0 <= i < n - 1 -> edge p[i] p[i + 1] f) /\
  edge p[n - 1] y f

(* This lemma states that if there is a path from x to y
   and if there is a path from y to z then there is a path
   from x to z *)
lemma trans_path : forall x y z : elt, f : elt -> elt, p1 p2 : seq elt.
  path f x y p1 -> path f y z p2 -> distinct (p1 ++ p2) ->
  path f x z (p1 ++ p2)

end